<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Smart Multi-Audio Speech Mixer</title>
<style>
  body { font-family: Arial, sans-serif; background:#f5f5f5; margin:20px; }
  textarea { width:100%; height:220px; font-size:16px; padding:10px; }
  button,input { margin-top:10px; font-size:16px; padding:8px 12px; }
  pre { background:#fff; padding:10px; border:1px solid #ccc; margin-top:15px; white-space:pre-wrap; }
  #wordList span { background:#e1f5fe; margin:3px; padding:4px 8px; border-radius:6px; display:inline-block; }
</style>
</head>
<body>

<h2>üéß Smart Multi-Audio + Speech Mixer</h2>

<textarea id="text">
Camino a la Playa

Sal√≠ temprano, todav√≠a con la neblina pegada en el parabrisas. No iba exactamente de paseo ‚Äîten√≠a que hacer una diligencia‚Äî, pero el destino daba justo frente al [AUDIO:mar], y eso ya hac√≠a que valiera un poco m√°s la pena.

El carro ol√≠a a filtro nuevo y a caf√© reci√©n comprado. Llevaba la m√∫sica bajita, m√°s por costumbre que por gusto; me gusta escuchar c√≥mo cambia el sonido de la ciudad al campo, como si los ruidos se fueran apagando uno por uno.

En la autopista, el sol empezaba a colarse por los espejos laterales. La gente que iba en moto ya ten√≠a el uniforme de la arena: gafas, chancletas y esa actitud de ‚Äúya casi llegamos‚Äù. Yo, en cambio, iba con la mente dividida entre la cita que ten√≠a que cumplir y las ganas de bajarme en cualquier lado solo a mirar el [AUDIO:mar] un rato.

En un punto, par√© en una tiendita a comprar agua. El due√±o estaba sentado afuera, con una hamaca medio colgando, mirando el cielo como si esperara que alguien lo saludara desde arriba. Le pregunt√© cu√°nto costaba la botella, y me dijo:
‚ÄîDepende. ¬øEs para calmar la sed o el [AUDIO:pensamiento]?

No supe si era poeta o simplemente estaba aburrido, pero le sonre√≠. Pagu√© y segu√≠ mi camino.

Cuando finalmente vi el [AUDIO:mar], fue como siempre: sin sorpresa, pero con respeto. Esa l√≠nea azul que nunca se cansa de estar ah√≠, movi√©ndose igual aunque uno llegue con prisas. Me estacion√© un minuto, baj√© la ventana y dej√© que el aire me pegara en la cara. No ten√≠a tiempo de quedarme, pero igual me di ese instante.

Pens√© en lo curioso que es: uno puede vivir cerca del [AUDIO:mar] o ir mil veces, y a√∫n as√≠, siempre hay algo que te detiene un momento. Como si el cuerpo recordara que tambi√©n necesita horizonte.

Arranqu√© de nuevo, con la sensaci√≥n de que, aunque iba a hacer una diligencia, igual hab√≠a ganado algo: cinco minutos de aire salado y silencio.</textarea>

<br>
<label>Word to record & replace:</label>
<input type="text" id="word" placeholder="Type a word (e.g. habits)">
<button id="recordBtn">‚è∫Ô∏è Record</button>
<button id="stopBtn" disabled>‚èπÔ∏è Stop</button>
<button id="replaceBtn" disabled>üîÑ Replace Word</button>
<button id="playBtn" disabled>‚ñ∂Ô∏è Play All</button>

<h4>üéµ Recorded Words:</h4>
<div id="wordList">(none yet)</div>

<pre id="output"></pre>

<script>
let mediaRecorder;
let recordedChunks = [];
let recordedAudios = {}; // almacena palabra -> blobURL
let originalText = "";
let currentWord = "";

const recordBtn = document.getElementById("recordBtn");
const stopBtn = document.getElementById("stopBtn");
const replaceBtn = document.getElementById("replaceBtn");
const playBtn = document.getElementById("playBtn");
const wordList = document.getElementById("wordList");
const output = document.getElementById("output");

function updateWordList() {
  if (Object.keys(recordedAudios).length === 0) {
    wordList.innerHTML = "(none yet)";
    return;
  }
  wordList.innerHTML = "";
  for (const w in recordedAudios) {
    const span = document.createElement("span");
    span.textContent = w;
    wordList.appendChild(span);
  }
}

// utilidades
function speakAsync(text, lang="es-US") {
  return new Promise(resolve => {
    const u = new SpeechSynthesisUtterance(text);
    u.lang = lang;
    u.onend = resolve;
    speechSynthesis.speak(u);
  });
}

function playAudioAsync(url, overlap=200) {
  return new Promise(resolve => {
    const audio = new Audio(url);
    let ended = false;
    audio.onended = () => { ended = true; resolve(); };
    audio.play();
    // Resuelve un poco antes para permitir solapamiento
    setTimeout(() => { if (!ended) resolve(); }, Math.max(200, audio.duration*1000 - overlap));
  });
}

// grabar audio
recordBtn.onclick = async () => {
  const w = document.getElementById("word").value.trim().toLowerCase();
  if (!w) return alert("Enter a word first!");
  currentWord = w;
  const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
  mediaRecorder = new MediaRecorder(stream);
  recordedChunks = [];
  mediaRecorder.ondataavailable = e => recordedChunks.push(e.data);
  mediaRecorder.onstop = () => {
    const blob = new Blob(recordedChunks, { type: "audio/webm" });
    const url = URL.createObjectURL(blob);
    recordedAudios[currentWord] = url; // guarda sin borrar los anteriores
    updateWordList();
    replaceBtn.disabled = false;
    playBtn.disabled = false;
    output.textContent = `‚úÖ Recorded audio for "${currentWord}".`;
  };
  mediaRecorder.start();
  recordBtn.disabled = true;
  stopBtn.disabled = false;
  output.textContent = `üéôÔ∏è Recording "${w}"...`;
};

stopBtn.onclick = () => {
  mediaRecorder.stop();
  recordBtn.disabled = false;
  stopBtn.disabled = true;
};

// reemplazar palabra
replaceBtn.onclick = () => {
  const textArea = document.getElementById("text");
  if (!originalText) originalText = textArea.value; // guarda copia original
  const regex = new RegExp(`\\b${currentWord}\\b`, "gi");
  textArea.value = textArea.value.replace(regex, `[AUDIO:${currentWord}]`);
  output.textContent = `üîÅ Replaced all "${currentWord}" with audio marker.`;
};

// reproducir todo con solapamiento
playBtn.onclick = async () => {
  const text = document.getElementById("text").value;
  const lang = "es-US";
  const parts = text.split(/(\[AUDIO:[^\]]+\])/g).filter(Boolean);
  output.textContent = "‚ñ∂Ô∏è Playing mixed text & audios...\n";

  speechSynthesis.cancel();

  for (const part of parts) {
    const match = part.match(/\[AUDIO:(.+)\]/);
    if (match) {
      const key = match[1];
      if (recordedAudios[key]) {
        output.textContent += `üîä ${key}\n`;
        await playAudioAsync(recordedAudios[key], 100);
      }
    } else if (part.trim()) {
      await speakAsync(part, lang);
    }
  }

  output.textContent += "\n‚úÖ Finished playback.";
};
</script>

</body>
</html>
